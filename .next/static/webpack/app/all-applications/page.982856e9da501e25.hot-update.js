"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/all-applications/page",{

/***/ "(app-pages-browser)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dbFunctions: () => (/* binding */ dbFunctions),\n/* harmony export */   supabase: () => (/* binding */ supabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\n// Supabase configuration\nconst supabaseUrl = \"https://rrtymhmlgypvflaycsap.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJydHltaG1sZ3lwdmZsYXljc2FwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAxMzU2MDksImV4cCI6MjA2NTcxMTYwOX0.XxdiIrZfQ_2G9Qk3r0mpVLy_wlcv2ned5bJslxB0l3U\";\n// Create Supabase client\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Database Functions\nconst dbFunctions = {\n    // Get all visa applications for an agent\n    async getApplications () {\n        var _session_user;\n        // Fetch the currently signed-in user so we can filter by owner_email\n        const { data: { session }, error: sessErr } = await supabase.auth.getSession();\n        if (sessErr) throw sessErr;\n        var _session_user_email;\n        const email = (_session_user_email = session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email) !== null && _session_user_email !== void 0 ? _session_user_email : '';\n        const { data, error } = await supabase.from('visa_applications').select('*').eq('owner_email', email).order('submitted_at', {\n            ascending: false\n        });\n        if (error) throw error;\n        return data;\n    },\n    // Create a new visa application\n    async createApplication (application) {\n        var _session_user;\n        const now = new Date().toISOString();\n        // Attach the owner_email from the current session\n        const { data: { session }, error: sessErr } = await supabase.auth.getSession();\n        if (sessErr) throw sessErr;\n        var _session_user_email;\n        const owner_email = (_session_user_email = session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email) !== null && _session_user_email !== void 0 ? _session_user_email : 'unknown@no-session';\n        const { data, error } = await supabase.from('visa_applications').insert([\n            {\n                ...application,\n                owner_email,\n                submitted_at: now,\n                last_updated_at: now\n            }\n        ]).select();\n        if (error) throw error;\n        return data[0];\n    },\n    // Update an existing application\n    async updateApplication (id, updates) {\n        const { data, error } = await supabase.from('visa_applications').update({\n            ...updates,\n            last_updated_at: new Date().toISOString()\n        }).eq('id', id).select();\n        if (error) throw error;\n        return data[0];\n    },\n    // Delete an application\n    async deleteApplication (id) {\n        const { error } = await supabase.from('visa_applications').delete().eq('id', id);\n        if (error) throw error;\n        return true;\n    },\n    // Get analytics data\n    async getAnalytics () {\n        var _session_user;\n        const { data: { session }, error: sessErr } = await supabase.auth.getSession();\n        if (sessErr) throw sessErr;\n        var _session_user_email;\n        const email = (_session_user_email = session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email) !== null && _session_user_email !== void 0 ? _session_user_email : '';\n        const { data: applications, error } = await supabase.from('visa_applications').select('*').eq('owner_email', email);\n        if (error) throw error;\n        // Calculate metrics\n        const totalApplications = applications.length;\n        const approvedApplications = applications.filter((app)=>app.application_status === 'APPROVED');\n        const pendingApplications = applications.filter((app)=>app.application_status === 'PENDING');\n        const rejectedApplications = applications.filter((app)=>app.application_status === 'REJECTED');\n        const totalRevenue = approvedApplications.reduce((sum, app)=>sum + app.fees, 0);\n        const totalCosts = approvedApplications.reduce((sum, app)=>sum + app.costs, 0);\n        const totalProfit = totalRevenue - totalCosts;\n        const pendingRevenue = pendingApplications.reduce((sum, app)=>sum + app.fees, 0);\n        const successRate = totalApplications > 0 ? Math.round(approvedApplications.length / totalApplications * 100 * 10) / 10 : 0;\n        return {\n            totalApplications,\n            pendingRevenue,\n            successRate,\n            totalRevenue: totalProfit,\n            approvedCount: approvedApplications.length,\n            pendingCount: pendingApplications.length,\n            rejectedCount: rejectedApplications.length,\n            applications\n        };\n    },\n    // Get monthly analytics for charts\n    async getMonthlyAnalytics () {\n        var _session_user;\n        const { data: { session }, error: sessErr } = await supabase.auth.getSession();\n        if (sessErr) throw sessErr;\n        var _session_user_email;\n        const email = (_session_user_email = session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email) !== null && _session_user_email !== void 0 ? _session_user_email : '';\n        const { data: applications, error } = await supabase.from('visa_applications').select('*').eq('owner_email', email).gte('submitted_at', new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString()); // Last 12 months\n        if (error) throw error;\n        // Group by month\n        const monthlyData = Array.from({\n            length: 12\n        }, (_, i)=>{\n            const date = new Date();\n            date.setMonth(date.getMonth() - (11 - i));\n            const month = date.toLocaleDateString('en-US', {\n                month: 'short'\n            });\n            const monthApplications = applications.filter((app)=>{\n                const appDate = new Date(app.submitted_at);\n                return appDate.getMonth() === date.getMonth() && appDate.getFullYear() === date.getFullYear();\n            });\n            const approvedThisMonth = monthApplications.filter((app)=>app.application_status === 'APPROVED');\n            const revenue = approvedThisMonth.reduce((sum, app)=>sum + (app.fees - app.costs), 0);\n            const successRate = monthApplications.length > 0 ? Math.round(approvedThisMonth.length / monthApplications.length * 100) : 0;\n            return {\n                month,\n                applications: monthApplications.length,\n                revenue,\n                successRate,\n                pending: monthApplications.filter((app)=>app.application_status === 'PENDING').length\n            };\n        });\n        return monthlyData;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUlkLFlBQVk7Z0JBQ3pDLE9BQU80QyxRQUFRSixRQUFRLE9BQU9GLEtBQUtFLFFBQVEsTUFBTUksUUFBUUMsV0FBVyxPQUFPUCxLQUFLTyxXQUFXO1lBQzdGO1lBRUEsTUFBTUMsb0JBQW9CSCxrQkFBa0I5QixNQUFNLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLGtCQUFrQixLQUFLO1lBQ3JGLE1BQU1nQyxVQUFVRCxrQkFBa0IzQixNQUFNLENBQUMsQ0FBQ0MsS0FBS04sTUFBUU0sTUFBT04sQ0FBQUEsSUFBSU8sSUFBSSxHQUFHUCxJQUFJUyxLQUFLLEdBQUc7WUFDckYsTUFBTUcsY0FBY2lCLGtCQUFrQmhDLE1BQU0sR0FBRyxJQUMzQ2dCLEtBQUtDLEtBQUssQ0FBQyxrQkFBbUJqQixNQUFNLEdBQUdnQyxrQkFBa0JoQyxNQUFNLEdBQUksT0FDbkU7WUFFSixPQUFPO2dCQUNMOEI7Z0JBQ0FoQyxjQUFja0Msa0JBQWtCaEMsTUFBTTtnQkFDdENvQztnQkFDQXJCO2dCQUNBc0IsU0FBU0wsa0JBQWtCOUIsTUFBTSxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJQyxrQkFBa0IsS0FBSyxXQUFXSixNQUFNO1lBQ3ZGO1FBQ0Y7UUFFQSxPQUFPdUI7SUFDVDtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYWJpYmkvTmV4dFByb2plY3QvTmV4dFByb2plY3QvbGliL3N1cGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblxuLy8gU3VwYWJhc2UgY29uZmlndXJhdGlvblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhXG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSFcblxuLy8gQ3JlYXRlIFN1cGFiYXNlIGNsaWVudFxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXkpXG5cbi8vIERhdGFiYXNlIFR5cGVzIChtYXRjaGluZyB5b3VyIGV4aXN0aW5nIHNjaGVtYSlcbmV4cG9ydCBpbnRlcmZhY2UgVmlzYUFwcGxpY2F0aW9uIHtcbiAgaWQ6IG51bWJlclxuICBmaXJzdF9uYW1lOiBzdHJpbmdcbiAgbWlkZGxlX25hbWU/OiBzdHJpbmdcbiAgbGFzdF9uYW1lOiBzdHJpbmdcbiAgZGF0ZV9vZl9iaXJ0aDogc3RyaW5nXG4gIHBhc3Nwb3J0X25vOiBzdHJpbmdcbiAgZ2VuZGVyPzogc3RyaW5nXG4gIHdoYXRzYXBwX251bWJlcjogc3RyaW5nXG4gIHZpc2FfdHlwZTogc3RyaW5nXG4gIGFwcGxpY2F0aW9uX3N0YXR1czogJ1BFTkRJTkcnIHwgJ0FQUFJPVkVEJyB8ICdSRUpFQ1RFRCdcbiAgc3VibWl0dGVkX2F0OiBzdHJpbmdcbiAgbGFzdF91cGRhdGVkX2F0OiBzdHJpbmdcbiAgZG9jdW1lbnRfdXJsczogc3RyaW5nW11cbiAgYWdlbnRfbm90ZXM/OiBzdHJpbmdcbiAgYWdlbnRfaWQ6IHN0cmluZ1xuICBmZWVzOiBudW1iZXJcbiAgY29zdHM6IG51bWJlclxuICB3aGF0c2FwcF9zZW50OiBib29sZWFuXG4gIGVtYWlsPzogc3RyaW5nXG4gIGRlc3RpbmF0aW9uOiBzdHJpbmdcbiAgb3duZXJfZW1haWw6IHN0cmluZ1xuICBhcHBfaWQ/OiBzdHJpbmdcbn1cblxuLy8gRGF0YWJhc2UgRnVuY3Rpb25zXG5leHBvcnQgY29uc3QgZGJGdW5jdGlvbnMgPSB7XG4gIC8vIEdldCBhbGwgdmlzYSBhcHBsaWNhdGlvbnMgZm9yIGFuIGFnZW50XG4gIGFzeW5jIGdldEFwcGxpY2F0aW9ucygpIHtcbiAgICAvLyBGZXRjaCB0aGUgY3VycmVudGx5IHNpZ25lZC1pbiB1c2VyIHNvIHdlIGNhbiBmaWx0ZXIgYnkgb3duZXJfZW1haWxcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgIGVycm9yOiBzZXNzRXJyLFxuICAgIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKTtcblxuICAgIGlmIChzZXNzRXJyKSB0aHJvdyBzZXNzRXJyO1xuICAgIGNvbnN0IGVtYWlsID0gc2Vzc2lvbj8udXNlcj8uZW1haWwgPz8gJyc7XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Zpc2FfYXBwbGljYXRpb25zJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdvd25lcl9lbWFpbCcsIGVtYWlsKVxuICAgICAgLm9yZGVyKCdzdWJtaXR0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIC8vIENyZWF0ZSBhIG5ldyB2aXNhIGFwcGxpY2F0aW9uXG4gIGFzeW5jIGNyZWF0ZUFwcGxpY2F0aW9uKGFwcGxpY2F0aW9uOiBPbWl0PFZpc2FBcHBsaWNhdGlvbiwgJ2lkJyB8ICdzdWJtaXR0ZWRfYXQnIHwgJ2xhc3RfdXBkYXRlZF9hdCcgfCAnb3duZXJfZW1haWwnPikge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcblxuICAgIC8vIEF0dGFjaCB0aGUgb3duZXJfZW1haWwgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAgY29uc3Qge1xuICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICBlcnJvcjogc2Vzc0VycixcbiAgICB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCk7XG5cbiAgICBpZiAoc2Vzc0VycikgdGhyb3cgc2Vzc0VycjtcbiAgICBjb25zdCBvd25lcl9lbWFpbCA9IHNlc3Npb24/LnVzZXI/LmVtYWlsID8/ICd1bmtub3duQG5vLXNlc3Npb24nO1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2aXNhX2FwcGxpY2F0aW9ucycpXG4gICAgICAuaW5zZXJ0KFtcbiAgICAgICAge1xuICAgICAgICAgIC4uLmFwcGxpY2F0aW9uLFxuICAgICAgICAgIG93bmVyX2VtYWlsLFxuICAgICAgICAgIHN1Ym1pdHRlZF9hdDogbm93LFxuICAgICAgICAgIGxhc3RfdXBkYXRlZF9hdDogbm93LFxuICAgICAgICB9LFxuICAgICAgXSlcbiAgICAgIC5zZWxlY3QoKTtcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgcmV0dXJuIGRhdGFbMF07XG4gIH0sXG5cbiAgLy8gVXBkYXRlIGFuIGV4aXN0aW5nIGFwcGxpY2F0aW9uXG4gIGFzeW5jIHVwZGF0ZUFwcGxpY2F0aW9uKGlkOiBudW1iZXIsIHVwZGF0ZXM6IFBhcnRpYWw8VmlzYUFwcGxpY2F0aW9uPikge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmlzYV9hcHBsaWNhdGlvbnMnKVxuICAgICAgLnVwZGF0ZSh7XG4gICAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICAgIGxhc3RfdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9KVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLnNlbGVjdCgpXG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiBkYXRhWzBdXG4gIH0sXG5cbiAgLy8gRGVsZXRlIGFuIGFwcGxpY2F0aW9uXG4gIGFzeW5jIGRlbGV0ZUFwcGxpY2F0aW9uKGlkOiBudW1iZXIpIHtcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Zpc2FfYXBwbGljYXRpb25zJylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4gdHJ1ZVxuICB9LFxuXG4gIC8vIEdldCBhbmFseXRpY3MgZGF0YVxuICBhc3luYyBnZXRBbmFseXRpY3MoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICBlcnJvcjogc2Vzc0VycixcbiAgICB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCk7XG5cbiAgICBpZiAoc2Vzc0VycikgdGhyb3cgc2Vzc0VycjtcbiAgICBjb25zdCBlbWFpbCA9IHNlc3Npb24/LnVzZXI/LmVtYWlsID8/ICcnO1xuXG4gICAgY29uc3QgeyBkYXRhOiBhcHBsaWNhdGlvbnMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Zpc2FfYXBwbGljYXRpb25zJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdvd25lcl9lbWFpbCcsIGVtYWlsKTtcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIG1ldHJpY3NcbiAgICBjb25zdCB0b3RhbEFwcGxpY2F0aW9ucyA9IGFwcGxpY2F0aW9ucy5sZW5ndGg7XG4gICAgY29uc3QgYXBwcm92ZWRBcHBsaWNhdGlvbnMgPSBhcHBsaWNhdGlvbnMuZmlsdGVyKGFwcCA9PiBhcHAuYXBwbGljYXRpb25fc3RhdHVzID09PSAnQVBQUk9WRUQnKVxuICAgIGNvbnN0IHBlbmRpbmdBcHBsaWNhdGlvbnMgPSBhcHBsaWNhdGlvbnMuZmlsdGVyKGFwcCA9PiBhcHAuYXBwbGljYXRpb25fc3RhdHVzID09PSAnUEVORElORycpXG4gICAgY29uc3QgcmVqZWN0ZWRBcHBsaWNhdGlvbnMgPSBhcHBsaWNhdGlvbnMuZmlsdGVyKGFwcCA9PiBhcHAuYXBwbGljYXRpb25fc3RhdHVzID09PSAnUkVKRUNURUQnKVxuICAgIFxuICAgIGNvbnN0IHRvdGFsUmV2ZW51ZSA9IGFwcHJvdmVkQXBwbGljYXRpb25zLnJlZHVjZSgoc3VtLCBhcHApID0+IHN1bSArIGFwcC5mZWVzLCAwKVxuICAgIGNvbnN0IHRvdGFsQ29zdHMgPSBhcHByb3ZlZEFwcGxpY2F0aW9ucy5yZWR1Y2UoKHN1bSwgYXBwKSA9PiBzdW0gKyBhcHAuY29zdHMsIDApXG4gICAgY29uc3QgdG90YWxQcm9maXQgPSB0b3RhbFJldmVudWUgLSB0b3RhbENvc3RzXG4gICAgXG4gICAgY29uc3QgcGVuZGluZ1JldmVudWUgPSBwZW5kaW5nQXBwbGljYXRpb25zLnJlZHVjZSgoc3VtLCBhcHApID0+IHN1bSArIGFwcC5mZWVzLCAwKVxuICAgIFxuICAgIGNvbnN0IHN1Y2Nlc3NSYXRlID0gdG90YWxBcHBsaWNhdGlvbnMgPiAwIFxuICAgICAgPyBNYXRoLnJvdW5kKChhcHByb3ZlZEFwcGxpY2F0aW9ucy5sZW5ndGggLyB0b3RhbEFwcGxpY2F0aW9ucykgKiAxMDAgKiAxMCkgLyAxMFxuICAgICAgOiAwXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsQXBwbGljYXRpb25zLFxuICAgICAgcGVuZGluZ1JldmVudWUsXG4gICAgICBzdWNjZXNzUmF0ZSxcbiAgICAgIHRvdGFsUmV2ZW51ZTogdG90YWxQcm9maXQsIC8vIFRoaXMgaXMgYWN0dWFsbHkgcHJvZml0XG4gICAgICBhcHByb3ZlZENvdW50OiBhcHByb3ZlZEFwcGxpY2F0aW9ucy5sZW5ndGgsXG4gICAgICBwZW5kaW5nQ291bnQ6IHBlbmRpbmdBcHBsaWNhdGlvbnMubGVuZ3RoLFxuICAgICAgcmVqZWN0ZWRDb3VudDogcmVqZWN0ZWRBcHBsaWNhdGlvbnMubGVuZ3RoLFxuICAgICAgYXBwbGljYXRpb25zXG4gICAgfVxuICB9LFxuXG4gIC8vIEdldCBtb250aGx5IGFuYWx5dGljcyBmb3IgY2hhcnRzXG4gIGFzeW5jIGdldE1vbnRobHlBbmFseXRpY3MoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YTogeyBzZXNzaW9uIH0sXG4gICAgICBlcnJvcjogc2Vzc0VycixcbiAgICB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCk7XG5cbiAgICBpZiAoc2Vzc0VycikgdGhyb3cgc2Vzc0VycjtcbiAgICBjb25zdCBlbWFpbCA9IHNlc3Npb24/LnVzZXI/LmVtYWlsID8/ICcnO1xuXG4gICAgY29uc3QgeyBkYXRhOiBhcHBsaWNhdGlvbnMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Zpc2FfYXBwbGljYXRpb25zJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdvd25lcl9lbWFpbCcsIGVtYWlsKVxuICAgICAgLmd0ZSgnc3VibWl0dGVkX2F0JywgbmV3IERhdGUoRGF0ZS5ub3coKSAtIDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkpOyAvLyBMYXN0IDEyIG1vbnRoc1xuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICBcbiAgICAvLyBHcm91cCBieSBtb250aFxuICAgIGNvbnN0IG1vbnRobHlEYXRhID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTIgfSwgKF8sIGkpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSAtICgxMSAtIGkpKVxuICAgICAgY29uc3QgbW9udGggPSBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7IG1vbnRoOiAnc2hvcnQnIH0pXG4gICAgICBcbiAgICAgIGNvbnN0IG1vbnRoQXBwbGljYXRpb25zID0gYXBwbGljYXRpb25zLmZpbHRlcihhcHAgPT4ge1xuICAgICAgICBjb25zdCBhcHBEYXRlID0gbmV3IERhdGUoYXBwLnN1Ym1pdHRlZF9hdClcbiAgICAgICAgcmV0dXJuIGFwcERhdGUuZ2V0TW9udGgoKSA9PT0gZGF0ZS5nZXRNb250aCgpICYmIGFwcERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICB9KVxuICAgICAgXG4gICAgICBjb25zdCBhcHByb3ZlZFRoaXNNb250aCA9IG1vbnRoQXBwbGljYXRpb25zLmZpbHRlcihhcHAgPT4gYXBwLmFwcGxpY2F0aW9uX3N0YXR1cyA9PT0gJ0FQUFJPVkVEJylcbiAgICAgIGNvbnN0IHJldmVudWUgPSBhcHByb3ZlZFRoaXNNb250aC5yZWR1Y2UoKHN1bSwgYXBwKSA9PiBzdW0gKyAoYXBwLmZlZXMgLSBhcHAuY29zdHMpLCAwKVxuICAgICAgY29uc3Qgc3VjY2Vzc1JhdGUgPSBtb250aEFwcGxpY2F0aW9ucy5sZW5ndGggPiAwIFxuICAgICAgICA/IE1hdGgucm91bmQoKGFwcHJvdmVkVGhpc01vbnRoLmxlbmd0aCAvIG1vbnRoQXBwbGljYXRpb25zLmxlbmd0aCkgKiAxMDApXG4gICAgICAgIDogMFxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb250aCxcbiAgICAgICAgYXBwbGljYXRpb25zOiBtb250aEFwcGxpY2F0aW9ucy5sZW5ndGgsXG4gICAgICAgIHJldmVudWUsXG4gICAgICAgIHN1Y2Nlc3NSYXRlLFxuICAgICAgICBwZW5kaW5nOiBtb250aEFwcGxpY2F0aW9ucy5maWx0ZXIoYXBwID0+IGFwcC5hcHBsaWNhdGlvbl9zdGF0dXMgPT09ICdQRU5ESU5HJykubGVuZ3RoXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICByZXR1cm4gbW9udGhseURhdGFcbiAgfVxufSAiXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJzdXBhYmFzZSIsImRiRnVuY3Rpb25zIiwiZ2V0QXBwbGljYXRpb25zIiwic2Vzc2lvbiIsImRhdGEiLCJlcnJvciIsInNlc3NFcnIiLCJhdXRoIiwiZ2V0U2Vzc2lvbiIsImVtYWlsIiwidXNlciIsImZyb20iLCJzZWxlY3QiLCJlcSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiY3JlYXRlQXBwbGljYXRpb24iLCJhcHBsaWNhdGlvbiIsIm5vdyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm93bmVyX2VtYWlsIiwiaW5zZXJ0Iiwic3VibWl0dGVkX2F0IiwibGFzdF91cGRhdGVkX2F0IiwidXBkYXRlQXBwbGljYXRpb24iLCJpZCIsInVwZGF0ZXMiLCJ1cGRhdGUiLCJkZWxldGVBcHBsaWNhdGlvbiIsImRlbGV0ZSIsImdldEFuYWx5dGljcyIsImFwcGxpY2F0aW9ucyIsInRvdGFsQXBwbGljYXRpb25zIiwibGVuZ3RoIiwiYXBwcm92ZWRBcHBsaWNhdGlvbnMiLCJmaWx0ZXIiLCJhcHAiLCJhcHBsaWNhdGlvbl9zdGF0dXMiLCJwZW5kaW5nQXBwbGljYXRpb25zIiwicmVqZWN0ZWRBcHBsaWNhdGlvbnMiLCJ0b3RhbFJldmVudWUiLCJyZWR1Y2UiLCJzdW0iLCJmZWVzIiwidG90YWxDb3N0cyIsImNvc3RzIiwidG90YWxQcm9maXQiLCJwZW5kaW5nUmV2ZW51ZSIsInN1Y2Nlc3NSYXRlIiwiTWF0aCIsInJvdW5kIiwiYXBwcm92ZWRDb3VudCIsInBlbmRpbmdDb3VudCIsInJlamVjdGVkQ291bnQiLCJnZXRNb250aGx5QW5hbHl0aWNzIiwiZ3RlIiwibW9udGhseURhdGEiLCJBcnJheSIsIl8iLCJpIiwiZGF0ZSIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJtb250aCIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIm1vbnRoQXBwbGljYXRpb25zIiwiYXBwRGF0ZSIsImdldEZ1bGxZZWFyIiwiYXBwcm92ZWRUaGlzTW9udGgiLCJyZXZlbnVlIiwicGVuZGluZyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/supabase.ts\n"));

/***/ })

});