"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/supabase.ts":
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dbFunctions: () => (/* binding */ dbFunctions),\n/* harmony export */   supabase: () => (/* binding */ supabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\n// Supabase configuration\nconst supabaseUrl = \"https://rrtymhmlgypvflaycsap.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJydHltaG1sZ3lwdmZsYXljc2FwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAxMzU2MDksImV4cCI6MjA2NTcxMTYwOX0.XxdiIrZfQ_2G9Qk3r0mpVLy_wlcv2ned5bJslxB0l3U\";\n// Create Supabase client\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n// Database Functions\nconst dbFunctions = {\n    // Get all visa applications for an agent\n    async getApplications () {\n        var _session_user;\n        // Fetch the currently signed-in user so we can filter by owner_email\n        const { data: { session }, error: sessErr } = await supabase.auth.getSession();\n        if (sessErr) throw sessErr;\n        var _session_user_email;\n        const email = (_session_user_email = session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email) !== null && _session_user_email !== void 0 ? _session_user_email : '';\n        const { data, error } = await supabase.from('visa_applications').select('*').eq('owner_email', email).order('submitted_at', {\n            ascending: false\n        });\n        if (error) throw error;\n        return data;\n    },\n    // Create a new visa application\n    async createApplication (application) {\n        var _session_user;\n        const now = new Date().toISOString();\n        // Attach the owner_email from the current session\n        const { data: { session }, error: sessErr } = await supabase.auth.getSession();\n        if (sessErr) throw sessErr;\n        var _session_user_email;\n        const owner_email = (_session_user_email = session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.email) !== null && _session_user_email !== void 0 ? _session_user_email : 'unknown@no-session';\n        const { data, error } = await supabase.from('visa_applications').insert([\n            {\n                ...application,\n                owner_email,\n                submitted_at: now,\n                last_updated_at: now\n            }\n        ]).select();\n        if (error) throw error;\n        return data[0];\n    },\n    // Update an existing application\n    async updateApplication (id, updates) {\n        const { data, error } = await supabase.from('visa_applications').update({\n            ...updates,\n            last_updated_at: new Date().toISOString()\n        }).eq('id', id).select();\n        if (error) throw error;\n        return data[0];\n    },\n    // Delete an application\n    async deleteApplication (id) {\n        const { error } = await supabase.from('visa_applications').delete().eq('id', id);\n        if (error) throw error;\n        return true;\n    },\n    // Get analytics data\n    async getAnalytics () {\n        let agentId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'Jawed';\n        const { data: applications, error } = await supabase.from('visa_applications').select('*').eq('agent_id', agentId);\n        if (error) throw error;\n        // Calculate metrics\n        const totalApplications = applications.length;\n        const approvedApplications = applications.filter((app)=>app.application_status === 'APPROVED');\n        const pendingApplications = applications.filter((app)=>app.application_status === 'PENDING');\n        const rejectedApplications = applications.filter((app)=>app.application_status === 'REJECTED');\n        const totalRevenue = approvedApplications.reduce((sum, app)=>sum + app.fees, 0);\n        const totalCosts = approvedApplications.reduce((sum, app)=>sum + app.costs, 0);\n        const totalProfit = totalRevenue - totalCosts;\n        const pendingRevenue = pendingApplications.reduce((sum, app)=>sum + app.fees, 0);\n        const successRate = totalApplications > 0 ? Math.round(approvedApplications.length / totalApplications * 100 * 10) / 10 : 0;\n        return {\n            totalApplications,\n            pendingRevenue,\n            successRate,\n            totalRevenue: totalProfit,\n            approvedCount: approvedApplications.length,\n            pendingCount: pendingApplications.length,\n            rejectedCount: rejectedApplications.length,\n            applications\n        };\n    },\n    // Get monthly analytics for charts\n    async getMonthlyAnalytics () {\n        let agentId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'Jawed';\n        const { data: applications, error } = await supabase.from('visa_applications').select('*').eq('agent_id', agentId).gte('submitted_at', new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString()) // Last 12 months\n        ;\n        if (error) throw error;\n        // Group by month\n        const monthlyData = Array.from({\n            length: 12\n        }, (_, i)=>{\n            const date = new Date();\n            date.setMonth(date.getMonth() - (11 - i));\n            const month = date.toLocaleDateString('en-US', {\n                month: 'short'\n            });\n            const monthApplications = applications.filter((app)=>{\n                const appDate = new Date(app.submitted_at);\n                return appDate.getMonth() === date.getMonth() && appDate.getFullYear() === date.getFullYear();\n            });\n            const approvedThisMonth = monthApplications.filter((app)=>app.application_status === 'APPROVED');\n            const revenue = approvedThisMonth.reduce((sum, app)=>sum + (app.fees - app.costs), 0);\n            const successRate = monthApplications.length > 0 ? Math.round(approvedThisMonth.length / monthApplications.length * 100) : 0;\n            return {\n                month,\n                applications: monthApplications.length,\n                revenue,\n                successRate,\n                pending: monthApplications.filter((app)=>app.application_status === 'PENDING').length\n            };\n        });\n        return monthlyData;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBckI7Z0JBQ0FzQixTQUFTTCxrQkFBa0I5QixNQUFNLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLGtCQUFrQixLQUFLLFdBQVdKLE1BQU07WUFDdkY7UUFDRjtRQUVBLE9BQU91QjtJQUNUO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2hhYmliaS9OZXh0UHJvamVjdC9OZXh0UHJvamVjdC9saWIvc3VwYWJhc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuXG4vLyBTdXBhYmFzZSBjb25maWd1cmF0aW9uXG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCFcbmNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIVxuXG4vLyBDcmVhdGUgU3VwYWJhc2UgY2xpZW50XG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSlcblxuLy8gRGF0YWJhc2UgVHlwZXMgKG1hdGNoaW5nIHlvdXIgZXhpc3Rpbmcgc2NoZW1hKVxuZXhwb3J0IGludGVyZmFjZSBWaXNhQXBwbGljYXRpb24ge1xuICBpZDogbnVtYmVyXG4gIGZpcnN0X25hbWU6IHN0cmluZ1xuICBtaWRkbGVfbmFtZT86IHN0cmluZ1xuICBsYXN0X25hbWU6IHN0cmluZ1xuICBkYXRlX29mX2JpcnRoOiBzdHJpbmdcbiAgcGFzc3BvcnRfbm86IHN0cmluZ1xuICBnZW5kZXI/OiBzdHJpbmdcbiAgd2hhdHNhcHBfbnVtYmVyOiBzdHJpbmdcbiAgdmlzYV90eXBlOiBzdHJpbmdcbiAgYXBwbGljYXRpb25fc3RhdHVzOiAnUEVORElORycgfCAnQVBQUk9WRUQnIHwgJ1JFSkVDVEVEJ1xuICBzdWJtaXR0ZWRfYXQ6IHN0cmluZ1xuICBsYXN0X3VwZGF0ZWRfYXQ6IHN0cmluZ1xuICBkb2N1bWVudF91cmxzOiBzdHJpbmdbXVxuICBhZ2VudF9ub3Rlcz86IHN0cmluZ1xuICBhZ2VudF9pZDogc3RyaW5nXG4gIGZlZXM6IG51bWJlclxuICBjb3N0czogbnVtYmVyXG4gIHdoYXRzYXBwX3NlbnQ6IGJvb2xlYW5cbiAgZW1haWw/OiBzdHJpbmdcbiAgZGVzdGluYXRpb246IHN0cmluZ1xufVxuXG4vLyBEYXRhYmFzZSBGdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBkYkZ1bmN0aW9ucyA9IHtcbiAgLy8gR2V0IGFsbCB2aXNhIGFwcGxpY2F0aW9ucyBmb3IgYW4gYWdlbnRcbiAgYXN5bmMgZ2V0QXBwbGljYXRpb25zKCkge1xuICAgIC8vIEZldGNoIHRoZSBjdXJyZW50bHkgc2lnbmVkLWluIHVzZXIgc28gd2UgY2FuIGZpbHRlciBieSBvd25lcl9lbWFpbFxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHsgc2Vzc2lvbiB9LFxuICAgICAgZXJyb3I6IHNlc3NFcnIsXG4gICAgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpO1xuXG4gICAgaWYgKHNlc3NFcnIpIHRocm93IHNlc3NFcnI7XG4gICAgY29uc3QgZW1haWwgPSBzZXNzaW9uPy51c2VyPy5lbWFpbCA/PyAnJztcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmlzYV9hcHBsaWNhdGlvbnMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ293bmVyX2VtYWlsJywgZW1haWwpXG4gICAgICAub3JkZXIoJ3N1Ym1pdHRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0sXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHZpc2EgYXBwbGljYXRpb25cbiAgYXN5bmMgY3JlYXRlQXBwbGljYXRpb24oYXBwbGljYXRpb246IE9taXQ8VmlzYUFwcGxpY2F0aW9uLCAnaWQnIHwgJ3N1Ym1pdHRlZF9hdCcgfCAnbGFzdF91cGRhdGVkX2F0JyB8ICdvd25lcl9lbWFpbCc+KSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXG4gICAgLy8gQXR0YWNoIHRoZSBvd25lcl9lbWFpbCBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7IHNlc3Npb24gfSxcbiAgICAgIGVycm9yOiBzZXNzRXJyLFxuICAgIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKTtcblxuICAgIGlmIChzZXNzRXJyKSB0aHJvdyBzZXNzRXJyO1xuICAgIGNvbnN0IG93bmVyX2VtYWlsID0gc2Vzc2lvbj8udXNlcj8uZW1haWwgPz8gJ3Vua25vd25Abm8tc2Vzc2lvbic7XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Zpc2FfYXBwbGljYXRpb25zJylcbiAgICAgIC5pbnNlcnQoW1xuICAgICAgICB7XG4gICAgICAgICAgLi4uYXBwbGljYXRpb24sXG4gICAgICAgICAgb3duZXJfZW1haWwsXG4gICAgICAgICAgc3VibWl0dGVkX2F0OiBub3csXG4gICAgICAgICAgbGFzdF91cGRhdGVkX2F0OiBub3csXG4gICAgICAgIH0sXG4gICAgICBdKVxuICAgICAgLnNlbGVjdCgpO1xuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICByZXR1cm4gZGF0YVswXTtcbiAgfSxcblxuICAvLyBVcGRhdGUgYW4gZXhpc3RpbmcgYXBwbGljYXRpb25cbiAgYXN5bmMgdXBkYXRlQXBwbGljYXRpb24oaWQ6IG51bWJlciwgdXBkYXRlczogUGFydGlhbDxWaXNhQXBwbGljYXRpb24+KSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2aXNhX2FwcGxpY2F0aW9ucycpXG4gICAgICAudXBkYXRlKHtcbiAgICAgICAgLi4udXBkYXRlcyxcbiAgICAgICAgbGFzdF91cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pXG4gICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAuc2VsZWN0KClcbiAgICBcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgcmV0dXJuIGRhdGFbMF1cbiAgfSxcblxuICAvLyBEZWxldGUgYW4gYXBwbGljYXRpb25cbiAgYXN5bmMgZGVsZXRlQXBwbGljYXRpb24oaWQ6IG51bWJlcikge1xuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmlzYV9hcHBsaWNhdGlvbnMnKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAuZXEoJ2lkJywgaWQpXG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiB0cnVlXG4gIH0sXG5cbiAgLy8gR2V0IGFuYWx5dGljcyBkYXRhXG4gIGFzeW5jIGdldEFuYWx5dGljcyhhZ2VudElkOiBzdHJpbmcgPSAnSmF3ZWQnKSB7XG4gICAgY29uc3QgeyBkYXRhOiBhcHBsaWNhdGlvbnMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3Zpc2FfYXBwbGljYXRpb25zJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdhZ2VudF9pZCcsIGFnZW50SWQpXG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBtZXRyaWNzXG4gICAgY29uc3QgdG90YWxBcHBsaWNhdGlvbnMgPSBhcHBsaWNhdGlvbnMubGVuZ3RoXG4gICAgY29uc3QgYXBwcm92ZWRBcHBsaWNhdGlvbnMgPSBhcHBsaWNhdGlvbnMuZmlsdGVyKGFwcCA9PiBhcHAuYXBwbGljYXRpb25fc3RhdHVzID09PSAnQVBQUk9WRUQnKVxuICAgIGNvbnN0IHBlbmRpbmdBcHBsaWNhdGlvbnMgPSBhcHBsaWNhdGlvbnMuZmlsdGVyKGFwcCA9PiBhcHAuYXBwbGljYXRpb25fc3RhdHVzID09PSAnUEVORElORycpXG4gICAgY29uc3QgcmVqZWN0ZWRBcHBsaWNhdGlvbnMgPSBhcHBsaWNhdGlvbnMuZmlsdGVyKGFwcCA9PiBhcHAuYXBwbGljYXRpb25fc3RhdHVzID09PSAnUkVKRUNURUQnKVxuICAgIFxuICAgIGNvbnN0IHRvdGFsUmV2ZW51ZSA9IGFwcHJvdmVkQXBwbGljYXRpb25zLnJlZHVjZSgoc3VtLCBhcHApID0+IHN1bSArIGFwcC5mZWVzLCAwKVxuICAgIGNvbnN0IHRvdGFsQ29zdHMgPSBhcHByb3ZlZEFwcGxpY2F0aW9ucy5yZWR1Y2UoKHN1bSwgYXBwKSA9PiBzdW0gKyBhcHAuY29zdHMsIDApXG4gICAgY29uc3QgdG90YWxQcm9maXQgPSB0b3RhbFJldmVudWUgLSB0b3RhbENvc3RzXG4gICAgXG4gICAgY29uc3QgcGVuZGluZ1JldmVudWUgPSBwZW5kaW5nQXBwbGljYXRpb25zLnJlZHVjZSgoc3VtLCBhcHApID0+IHN1bSArIGFwcC5mZWVzLCAwKVxuICAgIFxuICAgIGNvbnN0IHN1Y2Nlc3NSYXRlID0gdG90YWxBcHBsaWNhdGlvbnMgPiAwIFxuICAgICAgPyBNYXRoLnJvdW5kKChhcHByb3ZlZEFwcGxpY2F0aW9ucy5sZW5ndGggLyB0b3RhbEFwcGxpY2F0aW9ucykgKiAxMDAgKiAxMCkgLyAxMFxuICAgICAgOiAwXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsQXBwbGljYXRpb25zLFxuICAgICAgcGVuZGluZ1JldmVudWUsXG4gICAgICBzdWNjZXNzUmF0ZSxcbiAgICAgIHRvdGFsUmV2ZW51ZTogdG90YWxQcm9maXQsIC8vIFRoaXMgaXMgYWN0dWFsbHkgcHJvZml0XG4gICAgICBhcHByb3ZlZENvdW50OiBhcHByb3ZlZEFwcGxpY2F0aW9ucy5sZW5ndGgsXG4gICAgICBwZW5kaW5nQ291bnQ6IHBlbmRpbmdBcHBsaWNhdGlvbnMubGVuZ3RoLFxuICAgICAgcmVqZWN0ZWRDb3VudDogcmVqZWN0ZWRBcHBsaWNhdGlvbnMubGVuZ3RoLFxuICAgICAgYXBwbGljYXRpb25zXG4gICAgfVxuICB9LFxuXG4gIC8vIEdldCBtb250aGx5IGFuYWx5dGljcyBmb3IgY2hhcnRzXG4gIGFzeW5jIGdldE1vbnRobHlBbmFseXRpY3MoYWdlbnRJZDogc3RyaW5nID0gJ0phd2VkJykge1xuICAgIGNvbnN0IHsgZGF0YTogYXBwbGljYXRpb25zLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2aXNhX2FwcGxpY2F0aW9ucycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnYWdlbnRfaWQnLCBhZ2VudElkKVxuICAgICAgLmd0ZSgnc3VibWl0dGVkX2F0JywgbmV3IERhdGUoRGF0ZS5ub3coKSAtIDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkpIC8vIExhc3QgMTIgbW9udGhzXG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIFxuICAgIC8vIEdyb3VwIGJ5IG1vbnRoXG4gICAgY29uc3QgbW9udGhseURhdGEgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMiB9LCAoXywgaSkgPT4ge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKClcbiAgICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpIC0gKDExIC0gaSkpXG4gICAgICBjb25zdCBtb250aCA9IGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHsgbW9udGg6ICdzaG9ydCcgfSlcbiAgICAgIFxuICAgICAgY29uc3QgbW9udGhBcHBsaWNhdGlvbnMgPSBhcHBsaWNhdGlvbnMuZmlsdGVyKGFwcCA9PiB7XG4gICAgICAgIGNvbnN0IGFwcERhdGUgPSBuZXcgRGF0ZShhcHAuc3VibWl0dGVkX2F0KVxuICAgICAgICByZXR1cm4gYXBwRGF0ZS5nZXRNb250aCgpID09PSBkYXRlLmdldE1vbnRoKCkgJiYgYXBwRGF0ZS5nZXRGdWxsWWVhcigpID09PSBkYXRlLmdldEZ1bGxZZWFyKClcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGNvbnN0IGFwcHJvdmVkVGhpc01vbnRoID0gbW9udGhBcHBsaWNhdGlvbnMuZmlsdGVyKGFwcCA9PiBhcHAuYXBwbGljYXRpb25fc3RhdHVzID09PSAnQVBQUk9WRUQnKVxuICAgICAgY29uc3QgcmV2ZW51ZSA9IGFwcHJvdmVkVGhpc01vbnRoLnJlZHVjZSgoc3VtLCBhcHApID0+IHN1bSArIChhcHAuZmVlcyAtIGFwcC5jb3N0cyksIDApXG4gICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IG1vbnRoQXBwbGljYXRpb25zLmxlbmd0aCA+IDAgXG4gICAgICAgID8gTWF0aC5yb3VuZCgoYXBwcm92ZWRUaGlzTW9udGgubGVuZ3RoIC8gbW9udGhBcHBsaWNhdGlvbnMubGVuZ3RoKSAqIDEwMClcbiAgICAgICAgOiAwXG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vbnRoLFxuICAgICAgICBhcHBsaWNhdGlvbnM6IG1vbnRoQXBwbGljYXRpb25zLmxlbmd0aCxcbiAgICAgICAgcmV2ZW51ZSxcbiAgICAgICAgc3VjY2Vzc1JhdGUsXG4gICAgICAgIHBlbmRpbmc6IG1vbnRoQXBwbGljYXRpb25zLmZpbHRlcihhcHAgPT4gYXBwLmFwcGxpY2F0aW9uX3N0YXR1cyA9PT0gJ1BFTkRJTkcnKS5sZW5ndGhcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBtb250aGx5RGF0YVxuICB9XG59ICJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsInN1cGFiYXNlIiwiZGJGdW5jdGlvbnMiLCJnZXRBcHBsaWNhdGlvbnMiLCJzZXNzaW9uIiwiZGF0YSIsImVycm9yIiwic2Vzc0VyciIsImF1dGgiLCJnZXRTZXNzaW9uIiwiZW1haWwiLCJ1c2VyIiwiZnJvbSIsInNlbGVjdCIsImVxIiwib3JkZXIiLCJhc2NlbmRpbmciLCJjcmVhdGVBcHBsaWNhdGlvbiIsImFwcGxpY2F0aW9uIiwibm93IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwib3duZXJfZW1haWwiLCJpbnNlcnQiLCJzdWJtaXR0ZWRfYXQiLCJsYXN0X3VwZGF0ZWRfYXQiLCJ1cGRhdGVBcHBsaWNhdGlvbiIsImlkIiwidXBkYXRlcyIsInVwZGF0ZSIsImRlbGV0ZUFwcGxpY2F0aW9uIiwiZGVsZXRlIiwiZ2V0QW5hbHl0aWNzIiwiYWdlbnRJZCIsImFwcGxpY2F0aW9ucyIsInRvdGFsQXBwbGljYXRpb25zIiwibGVuZ3RoIiwiYXBwcm92ZWRBcHBsaWNhdGlvbnMiLCJmaWx0ZXIiLCJhcHAiLCJhcHBsaWNhdGlvbl9zdGF0dXMiLCJwZW5kaW5nQXBwbGljYXRpb25zIiwicmVqZWN0ZWRBcHBsaWNhdGlvbnMiLCJ0b3RhbFJldmVudWUiLCJyZWR1Y2UiLCJzdW0iLCJmZWVzIiwidG90YWxDb3N0cyIsImNvc3RzIiwidG90YWxQcm9maXQiLCJwZW5kaW5nUmV2ZW51ZSIsInN1Y2Nlc3NSYXRlIiwiTWF0aCIsInJvdW5kIiwiYXBwcm92ZWRDb3VudCIsInBlbmRpbmdDb3VudCIsInJlamVjdGVkQ291bnQiLCJnZXRNb250aGx5QW5hbHl0aWNzIiwiZ3RlIiwibW9udGhseURhdGEiLCJBcnJheSIsIl8iLCJpIiwiZGF0ZSIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJtb250aCIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIm1vbnRoQXBwbGljYXRpb25zIiwiYXBwRGF0ZSIsImdldEZ1bGxZZWFyIiwiYXBwcm92ZWRUaGlzTW9udGgiLCJyZXZlbnVlIiwicGVuZGluZyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/supabase.ts\n"));

/***/ })

});